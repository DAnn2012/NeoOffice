Index: svtools/source/misc/documentlockfile.cxx
===================================================================
--- svtools/source/misc/documentlockfile.cxx	(.../tags/DEV300_m35)	(revision 274104)
+++ svtools/source/misc/documentlockfile.cxx	(.../cws/mav43)	(revision 274104)
@@ -317,6 +317,33 @@
 }
 
 // ----------------------------------------------------------------------
+sal_Bool DocumentLockFile::OverwriteOwnLockFile()
+{
+    // allows to overwrite the lock file with the current data
+    try
+    {
+        uno::Reference < ::com::sun::star::ucb::XCommandEnvironment > xEnv;
+        ::ucbhelper::Content aTargetContent( m_aURL, xEnv );
+
+        uno::Sequence< ::rtl::OUString > aNewEntry = GenerateOwnEntry();
+
+        uno::Reference< io::XStream > xStream = aTargetContent.openWriteableStreamNoLock();
+        uno::Reference< io::XOutputStream > xOutput = xStream->getOutputStream();
+        uno::Reference< io::XTruncate > xTruncate( xOutput, uno::UNO_QUERY_THROW );
+
+        xTruncate->truncate();
+        WriteEntryToStream( aNewEntry, xOutput );
+        xOutput->closeOutput();
+    }
+    catch( ucb::NameClashException& )
+    {
+        return sal_False;
+    }
+
+    return sal_True;
+}
+
+// ----------------------------------------------------------------------
 void DocumentLockFile::RemoveFile()
 {
     // TODO/LATER: the removing is not atomar, is it possible in general to make it atomar?
Index: svtools/source/passwordcontainer/passwordcontainer.cxx
===================================================================
--- svtools/source/passwordcontainer/passwordcontainer.cxx	(.../tags/DEV300_m35)	(revision 274104)
+++ svtools/source/passwordcontainer/passwordcontainer.cxx	(.../cws/mav43)	(revision 274104)
@@ -342,7 +342,7 @@
 
 //-------------------------------------------------------------------------
 
-void StorageItem::setEncodedMP( const ::rtl::OUString& aEncoded )
+void StorageItem::setEncodedMP( const ::rtl::OUString& aEncoded, sal_Bool bAcceptEmpty )
 {
     Sequence< ::rtl::OUString > sendNames(2);
     Sequence< uno::Any > sendVals(2);
@@ -350,7 +350,7 @@
     sendNames[0] = ::rtl::OUString::createFromAscii( "HasMaster" );
     sendNames[1] = ::rtl::OUString::createFromAscii( "Master" );
 
-    sal_Bool bHasMaster = ( aEncoded.getLength() > 0 );
+    sal_Bool bHasMaster = ( aEncoded.getLength() > 0 || bAcceptEmpty );
     sendVals[0] <<= bHasMaster;
     sendVals[1] <<= aEncoded;
     
@@ -858,6 +858,16 @@
 }
 
 //-------------------------------------------------------------------------
+::rtl::OUString PasswordContainer::GetDefaultMasterPassword()
+{
+    ::rtl::OUString aResult;
+    for ( sal_Int32 nInd = 0; nInd < RTL_DIGEST_LENGTH_MD5; nInd++ )
+        aResult += ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "aa" ) );
+
+    return aResult;
+}
+
+//-------------------------------------------------------------------------
 ::rtl::OUString PasswordContainer::RequestPasswordFromUser( PasswordRequestMode aRMode, const uno::Reference< task::XInteractionHandler >& xHandler )
 {
     // empty string means that the call was cancelled or just failed
@@ -898,38 +908,47 @@
     if( !m_aMasterPasswd.getLength() && aHandler.is() )
     {
         ::rtl::OUString aEncodedMP;
-        sal_Bool bAskAgain;
+        sal_Bool bAskAgain = sal_False;
+        sal_Bool bDefaultPassword = sal_False;
 
         if( !m_pStorageFile->getEncodedMP( aEncodedMP ) )
             aRMode = PasswordRequestMode_PASSWORD_CREATE;
-        
-        do {
-            bAskAgain = sal_False;
+        else if ( !aEncodedMP.getLength() )
+        {
+            m_aMasterPasswd = GetDefaultMasterPassword();
+            bDefaultPassword = sal_True;
+        }
 
-            ::rtl::OUString aPass = RequestPasswordFromUser( aRMode, aHandler );
-            if ( aPass.getLength() )
-            {
-                if( aRMode == PasswordRequestMode_PASSWORD_CREATE )
+        if ( !bDefaultPassword )
+        {
+            do {
+                bAskAgain = sal_False;
+
+                ::rtl::OUString aPass = RequestPasswordFromUser( aRMode, aHandler );
+                if ( aPass.getLength() )
                 {
-                    m_aMasterPasswd = aPass;
-                    vector< ::rtl::OUString > aMaster( 1, m_aMasterPasswd );
-                    
-                    m_pStorageFile->setEncodedMP( EncodePasswords( aMaster, m_aMasterPasswd ) );
-                }
-                else
-                {
-                    vector< ::rtl::OUString > aRM( DecodePasswords( aEncodedMP, aPass ) );
-                    if( !aRM.size() || !aPass.equals( aRM[0] ) )
+                    if( aRMode == PasswordRequestMode_PASSWORD_CREATE )
                     {
-                        bAskAgain = sal_True;
-                        aRMode = PasswordRequestMode_PASSWORD_REENTER;
+                        m_aMasterPasswd = aPass;
+                        vector< ::rtl::OUString > aMaster( 1, m_aMasterPasswd );
+                        
+                        m_pStorageFile->setEncodedMP( EncodePasswords( aMaster, m_aMasterPasswd ) );
                     }
                     else
-                        m_aMasterPasswd = aPass;
+                    {
+                        vector< ::rtl::OUString > aRM( DecodePasswords( aEncodedMP, aPass ) );
+                        if( !aRM.size() || !aPass.equals( aRM[0] ) )
+                        {
+                            bAskAgain = sal_True;
+                            aRMode = PasswordRequestMode_PASSWORD_REENTER;
+                        }
+                        else
+                            m_aMasterPasswd = aPass;
+                    }
                 }
-            }
 
-        } while( bAskAgain );
+            } while( bAskAgain );
+        }
     }
 
     if ( !m_aMasterPasswd.getLength() )
@@ -1110,33 +1129,42 @@
     // the method should fail if there is no master password
     if( m_pStorageFile && m_pStorageFile->useStorage() && m_pStorageFile->getEncodedMP( aEncodedMP ) )
     {
-        if ( !xTmpHandler.is() )
+        if ( !aEncodedMP.getLength() )
         {
-            uno::Reference< lang::XMultiServiceFactory > xFactory( mComponent, uno::UNO_QUERY_THROW );
-            xTmpHandler.set( xFactory->createInstance( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.task.InteractionHandler" ) ) ), uno::UNO_QUERY_THROW );
+            // this is a default master password
+            // no UI is necessary
+            bResult = sal_True;
         }
-
-        if ( m_aMasterPasswd.getLength() )
-        {
-            // there is a password, it should be just rechecked
-            PasswordRequestMode aRMode = PasswordRequestMode_PASSWORD_ENTER;
-            ::rtl::OUString aPass;
-            
-            do {
-                aPass = RequestPasswordFromUser( aRMode, xTmpHandler );
-                bResult = ( aPass.getLength() && aPass.equals( m_aMasterPasswd ) );
-                aRMode = PasswordRequestMode_PASSWORD_REENTER; // further questions with error notification
-            } while( !bResult && aPass.getLength() );
-        }
         else
         {
-            try
+            if ( !xTmpHandler.is() )
             {
-                // ask for the password, if user provide no correct password an exception will be thrown
-                bResult = ( GetMasterPassword( xTmpHandler ).getLength() > 0 );
+                uno::Reference< lang::XMultiServiceFactory > xFactory( mComponent, uno::UNO_QUERY_THROW );
+                xTmpHandler.set( xFactory->createInstance( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.task.InteractionHandler" ) ) ), uno::UNO_QUERY_THROW );
             }
-            catch( uno::Exception& )
-            {}
+
+            if ( m_aMasterPasswd.getLength() )
+            {
+                // there is a password, it should be just rechecked
+                PasswordRequestMode aRMode = PasswordRequestMode_PASSWORD_ENTER;
+                ::rtl::OUString aPass;
+                
+                do {
+                    aPass = RequestPasswordFromUser( aRMode, xTmpHandler );
+                    bResult = ( aPass.getLength() && aPass.equals( m_aMasterPasswd ) );
+                    aRMode = PasswordRequestMode_PASSWORD_REENTER; // further questions with error notification
+                } while( !bResult && aPass.getLength() );
+            }
+            else
+            {
+                try
+                {
+                    // ask for the password, if user provide no correct password an exception will be thrown
+                    bResult = ( GetMasterPassword( xTmpHandler ).getLength() > 0 );
+                }
+                catch( uno::Exception& )
+                {}
+            }
         }
     }
 
@@ -1260,7 +1288,75 @@
 }
 
 //-------------------------------------------------------------------------
+::sal_Bool SAL_CALL PasswordContainer::useDefaultMasterPassword( const uno::Reference< task::XInteractionHandler >& xHandler )
+    throw ( uno::RuntimeException )
+{
+    sal_Bool bResult = sal_False;
+    uno::Reference< task::XInteractionHandler > xTmpHandler = xHandler;
+    ::osl::MutexGuard aGuard( mMutex );
+    
+    if ( m_pStorageFile && m_pStorageFile->useStorage() )
+    {
+        if ( !xTmpHandler.is() )
+        {
+            uno::Reference< lang::XMultiServiceFactory > xFactory( mComponent, uno::UNO_QUERY_THROW );
+            xTmpHandler.set( xFactory->createInstance( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.task.InteractionHandler" ) ) ), uno::UNO_QUERY_THROW );
+        }
 
+        sal_Bool bCanChangePassword = sal_True;
+        // if there is already a stored nondefault master password it should be entered by the user before the change happen
+        ::rtl::OUString aEncodedMP;
+        if( m_pStorageFile->getEncodedMP( aEncodedMP ) && aEncodedMP.getLength() )
+            bCanChangePassword = authorizateWithMasterPassword( xTmpHandler );
+
+        if ( bCanChangePassword )
+        {
+            // generate the default password
+            ::rtl::OUString aPass = GetDefaultMasterPassword();
+            if ( aPass.getLength() )
+            {
+                // get all the persistent entries if it is possible
+                Sequence< UrlRecord > aPersistent = getAllPersistent( uno::Reference< task::XInteractionHandler >() );
+
+                // remove the master password and the entries persistence
+                removeMasterPassword();
+
+                // store the empty string to flag the default master password
+                m_aMasterPasswd = aPass;
+                m_pStorageFile->setEncodedMP( ::rtl::OUString(), sal_True );
+
+                // store all the entries with the new password
+                for ( int nURLInd = 0; nURLInd < aPersistent.getLength(); nURLInd++ )
+                    for ( int nNameInd = 0; nNameInd< aPersistent[nURLInd].UserList.getLength(); nNameInd++ )
+                        addPersistent( aPersistent[nURLInd].Url,
+                                       aPersistent[nURLInd].UserList[nNameInd].UserName,
+                                       aPersistent[nURLInd].UserList[nNameInd].Passwords,
+                                       uno::Reference< task::XInteractionHandler >() );
+
+                bResult = sal_True;
+            }
+        }
+    }
+
+    return bResult;
+
+}
+
+//-------------------------------------------------------------------------
+::sal_Bool SAL_CALL PasswordContainer::isDefaultMasterPasswordUsed()
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( mMutex );
+
+    if ( !m_pStorageFile )
+        throw uno::RuntimeException();
+
+    ::rtl::OUString aEncodedMP;
+    return ( m_pStorageFile->useStorage() && m_pStorageFile->getEncodedMP( aEncodedMP ) && !aEncodedMP.getLength() );
+}
+
+//-------------------------------------------------------------------------
+
 void PasswordContainer::Notify()
 {
     ::osl::MutexGuard aGuard( mMutex );
Index: svtools/source/inc/passwordcontainer.hxx
===================================================================
--- svtools/source/inc/passwordcontainer.hxx	(.../tags/DEV300_m35)	(revision 274104)
+++ svtools/source/inc/passwordcontainer.hxx	(.../cws/mav43)	(revision 274104)
@@ -39,7 +39,7 @@
 #include <com/sun/star/lang/XSingleServiceFactory.hpp>
 #include <com/sun/star/lang/XEventListener.hpp>
 #include <com/sun/star/lang/XComponent.hpp>
-#include <com/sun/star/task/XMasterPasswordHandling.hpp>
+#include <com/sun/star/task/XMasterPasswordHandling2.hpp>
 #include <cppuhelper/implbase4.hxx>
 #include <cppuhelper/typeprovider.hxx>
 #include <cppuhelper/queryinterface.hxx>
@@ -225,7 +225,7 @@
     void clear();
 
     sal_Bool getEncodedMP( ::rtl::OUString& aResult );
-    void setEncodedMP( const ::rtl::OUString& aResult );
+    void setEncodedMP( const ::rtl::OUString& aResult, sal_Bool bAcceptEnmpty = sal_False );
     void setUseStorage( sal_Bool bUse );
     sal_Bool useStorage();
     
@@ -243,7 +243,7 @@
 
 class PasswordContainer : public ::cppu::WeakImplHelper4<
         ::com::sun::star::task::XPasswordContainer,
-        ::com::sun::star::task::XMasterPasswordHandling,
+        ::com::sun::star::task::XMasterPasswordHandling2,
         ::com::sun::star::lang::XServiceInfo,
         ::com::sun::star::lang::XEventListener >
 {
@@ -270,6 +270,8 @@
                                         const ::com::sun::star::uno::Reference< ::com::sun::star::task::XInteractionHandler >& Handler )
                                                         throw(::com::sun::star::uno::RuntimeException);
 
+    ::rtl::OUString GetDefaultMasterPassword();
+
     ::rtl::OUString RequestPasswordFromUser(
                     ::com::sun::star::task::PasswordRequestMode aRMode,
                     const ::com::sun::star::uno::Reference< ::com::sun::star::task::XInteractionHandler >& xHandler );
@@ -363,6 +365,10 @@
     virtual ::sal_Bool SAL_CALL allowPersistentStoring( ::sal_Bool bAllow ) throw (::com::sun::star::uno::RuntimeException);
     virtual ::sal_Bool SAL_CALL isPersistentStoringAllowed(  ) throw (::com::sun::star::uno::RuntimeException);
 
+    // XMasterPasswordHandling2
+    virtual ::sal_Bool SAL_CALL useDefaultMasterPassword( const ::com::sun::star::uno::Reference< ::com::sun::star::task::XInteractionHandler >& xHandler ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL isDefaultMasterPasswordUsed(  ) throw (::com::sun::star::uno::RuntimeException);
+
     void            Notify();
 };
 
Index: svtools/inc/svtools/documentlockfile.hxx
===================================================================
--- svtools/inc/svtools/documentlockfile.hxx	(.../tags/DEV300_m35)	(revision 274104)
+++ svtools/inc/svtools/documentlockfile.hxx	(.../cws/mav43)	(revision 274104)
@@ -79,6 +79,7 @@
     sal_Bool CreateOwnLockFile();
     ::com::sun::star::uno::Sequence< ::rtl::OUString > GetLockData();
     ::com::sun::star::uno::Sequence< ::rtl::OUString > GenerateOwnEntry();
+    sal_Bool OverwriteOwnLockFile();
     void RemoveFile();
 
     // the methods allow to control whether UI interaction regarding the locked document file is allowed
