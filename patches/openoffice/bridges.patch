--- source/cpp_uno/gcc3_macosx_intel/except.cxx	2008-04-11 03:43:43.000000000 -0700
+++ source/cpp_uno/gcc3_macosx_intel/except.cxx	2013-09-12 22:21:02.000000000 -0700
@@ -1,40 +1,35 @@
-/*************************************************************************
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/*
+ * This file is part of the LibreOffice project.
  *
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- * 
- * Copyright 2008 by Sun Microsystems, Inc.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  *
- * OpenOffice.org - a multi-platform office productivity suite
+ * This file incorporates work covered by the following license notice:
  *
- * $RCSfile$
- * $Revision$
- *
- * This file is part of OpenOffice.org.
- *
- * OpenOffice.org is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License version 3
- * only, as published by the Free Software Foundation.
- *
- * OpenOffice.org is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3 for more details
- * (a copy is included in the LICENSE file that accompanied this code).
- *
- * You should have received a copy of the GNU Lesser General Public License
- * version 3 along with OpenOffice.org.  If not, see
- * <http://www.openoffice.org/license.html>
- * for a copy of the LGPLv3 License.
- *
- ************************************************************************/
+ *   Licensed to the Apache Software Foundation (ASF) under one or more
+ *   contributor license agreements. See the NOTICE file distributed
+ *   with this work for additional information regarding copyright
+ *   ownership. The ASF licenses this file to you under the Apache
+ *   License, Version 2.0 (the "License"); you may not use this file
+ *   except in compliance with the License. You may obtain a copy of
+ *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
+ */
 
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_bridges.hxx"
 
 #include <stdio.h>
 #include <dlfcn.h>
+#if MACOSX_SDK_VERSION < 1070
 #include <cxxabi.h>
+#else
+#include <typeinfo>
+#endif
+#if SUPD == 310
 #include <hash_map>
+#else	// SUPD == 310
+#include <boost/unordered_map.hpp>
+#endif	// SUPD == 310
 
 #include <rtl/strbuf.hxx>
 #include <rtl/ustrbuf.hxx>
@@ -53,18 +48,68 @@
 using namespace ::osl;
 using namespace ::rtl;
 using namespace ::com::sun::star::uno;
+#if MACOSX_SDK_VERSION < 1070
 using namespace ::__cxxabiv1;
-
+#endif
 
 namespace CPPU_CURRENT_NAMESPACE
 {
 
+#if MACOSX_SDK_VERSION >= 1070
+
+// MacOSX10.4u.sdk/usr/include/c++/4.0.0/cxxabi.h defined
+// __cxxabiv1::__class_type_info and __cxxabiv1::__si_class_type_info but
+// MacOSX10.7.sdk/usr/include/cxxabi.h no longer does, so instances of those
+// classes need to be created manually:
+
+// std::type_info defined in <typeinfo> offers a protected ctor:
+struct FAKE_type_info: public std::type_info {
+    FAKE_type_info(char const * name): type_info(name) {}
+};
+
+// Modeled after __cxxabiv1::__si_class_type_info defined in
+// MacOSX10.4u.sdk/usr/include/c++/4.0.0/cxxabi.h (i.e.,
+// abi::__si_class_type_info documented at
+// <http://www.codesourcery.com/public/cxx-abi/abi.html#rtti>):
+struct FAKE_si_class_type_info: public FAKE_type_info {
+    FAKE_si_class_type_info(char const * name, std::type_info const * theBase):
+        FAKE_type_info(name), base(theBase) {}
+
+    std::type_info const * base;
+        // actually a __cxxabiv1::__class_type_info pointer
+};
+
+struct Base {};
+struct Derived: Base {};
+
+std::type_info * create_FAKE_class_type_info(char const * name) {
+    std::type_info * p = new FAKE_type_info(name);
+        // cxxabiv1::__class_type_info has no data members in addition to
+        // std::type_info
+    *reinterpret_cast< void ** >(p) = *reinterpret_cast< void * const * >(
+        &typeid(Base));
+        // copy correct __cxxabiv1::__class_type_info vtable into place
+    return p;
+}
+
+std::type_info * create_FAKE_si_class_type_info(
+    char const * name, std::type_info const * base)
+{
+    std::type_info * p = new FAKE_si_class_type_info(name, base);
+    *reinterpret_cast< void ** >(p) = *reinterpret_cast< void * const * >(
+        &typeid(Derived));
+        // copy correct __cxxabiv1::__si_class_type_info vtable into place
+    return p;
+}
+
+#endif
+
 void dummy_can_throw_anything( char const * )
 {
 }
 
 //==================================================================================================
-static OUString toUNOname( char const * p ) SAL_THROW( () )
+static OUString toUNOname( char const * p ) SAL_THROW(())
 {
 #if OSL_DEBUG_LEVEL > 1
     char const * start = p;
@@ -72,7 +117,7 @@
 
     // example: N3com3sun4star4lang24IllegalArgumentExceptionE
 
-	OUStringBuffer buf( 64 );
+    OUStringBuffer buf( 64 );
     OSL_ASSERT( 'N' == *p );
     ++p; // skip N
 
@@ -104,33 +149,37 @@
 //==================================================================================================
 class RTTI
 {
+#if SUPD == 310
     typedef hash_map< OUString, type_info *, OUStringHash > t_rtti_map;
+#else	// SUPD == 310
+    typedef boost::unordered_map< OUString, type_info *, OUStringHash > t_rtti_map;
+#endif	// SUPD == 310
 
     Mutex m_mutex;
-	t_rtti_map m_rttis;
+    t_rtti_map m_rttis;
     t_rtti_map m_generatedRttis;
 
     void * m_hApp;
 
 public:
-    RTTI() SAL_THROW( () );
-    ~RTTI() SAL_THROW( () );
+    RTTI() SAL_THROW(());
+    ~RTTI() SAL_THROW(());
 
-    type_info * getRTTI( typelib_CompoundTypeDescription * ) SAL_THROW( () );
+    type_info * getRTTI( typelib_CompoundTypeDescription * ) SAL_THROW(());
 };
 //__________________________________________________________________________________________________
-RTTI::RTTI() SAL_THROW( () )
+RTTI::RTTI() SAL_THROW(())
     : m_hApp( dlopen( 0, RTLD_LAZY ) )
 {
 }
 //__________________________________________________________________________________________________
-RTTI::~RTTI() SAL_THROW( () )
+RTTI::~RTTI() SAL_THROW(())
 {
     dlclose( m_hApp );
 }
 
 //__________________________________________________________________________________________________
-type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW( () )
+type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW(())
 {
     type_info * rtti;
 
@@ -142,7 +191,7 @@
     {
         // RTTI symbol
         OStringBuffer buf( 64 );
-        buf.append( RTL_CONSTASCII_STRINGPARAM("_ZTIN") );
+        buf.append( "_ZTIN" );
         sal_Int32 index = 0;
         do
         {
@@ -161,7 +210,13 @@
         {
             pair< t_rtti_map::iterator, bool > insertion(
                 m_rttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+#if SUPD == 310
             OSL_ENSURE( insertion.second, "### inserting new rtti failed?!" );
+#else	// SUPD == 310
+            SAL_WARN_IF( !insertion.second,
+                         "bridges",
+                         "inserting new rtti failed" );
+#endif	// SUPD == 310
         }
         else
         {
@@ -181,18 +236,33 @@
                     // ensure availability of base
                     type_info * base_rtti = getRTTI(
                         (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
+#if MACOSX_SDK_VERSION < 1070
                     rtti = new __si_class_type_info(
                         strdup( rttiName ), (__class_type_info *)base_rtti );
+#else
+                    rtti = create_FAKE_si_class_type_info(
+                        strdup( rttiName ), base_rtti );
+#endif
                 }
                 else
                 {
                     // this class has no base class
+#if MACOSX_SDK_VERSION < 1070
                     rtti = new __class_type_info( strdup( rttiName ) );
+#else
+                    rtti = create_FAKE_class_type_info( strdup( rttiName ) );
+#endif
                 }
 
                 pair< t_rtti_map::iterator, bool > insertion(
                     m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+#if SUPD == 310
                 OSL_ENSURE( insertion.second, "### inserting new generated rtti failed?!" );
+#else	// SUPD == 310
+                SAL_WARN_IF( !insertion.second,
+                             "bridges",
+                             "inserting new generated rtti failed" );
+#endif	// SUPD == 310
             }
             else // taking already generated rtti
             {
@@ -218,9 +288,9 @@
     OSL_ENSURE( pTD, "### unknown exception type! leaving out destruction => leaking!!!" );
     if (pTD)
     {
-		::uno_destructData( pExc, pTD, cpp_release );
-		::typelib_typedescription_release( pTD );
-	}
+        ::uno_destructData( pExc, pTD, cpp_release );
+        ::typelib_typedescription_release( pTD );
+    }
 }
 
 //==================================================================================================
@@ -231,29 +301,33 @@
         OUStringToOString(
             *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
             RTL_TEXTENCODING_ASCII_US ) );
-    fprintf( stderr, "> uno exception occured: %s\n", cstr.getStr() );
+    fprintf( stderr, "> uno exception occurred: %s\n", cstr.getStr() );
 #endif
     void * pCppExc;
     type_info * rtti;
 
     {
     // construct cpp exception object
-	typelib_TypeDescription * pTypeDescr = 0;
-	TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
+    typelib_TypeDescription * pTypeDescr = 0;
+    TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
     OSL_ASSERT( pTypeDescr );
     if (! pTypeDescr)
     {
         throw RuntimeException(
+#if SUPD == 310
             OUString( RTL_CONSTASCII_USTRINGPARAM("cannot get typedescription for type ") ) +
+#else	// SUPD == 310
+            OUString("cannot get typedescription for type ") +
+#endif	// SUPD == 310
             *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
             Reference< XInterface >() );
     }
 
-	pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
-	::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
+    pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
+    ::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
 
-	// destruct uno exception
-	::uno_any_destruct( pUnoExc, 0 );
+    // destruct uno exception
+    ::uno_any_destruct( pUnoExc, 0 );
     // avoiding locked counts
     static RTTI * s_rtti = 0;
     if (! s_rtti)
@@ -269,19 +343,23 @@
 #endif
         }
     }
-	rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
+    rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
     TYPELIB_DANGER_RELEASE( pTypeDescr );
     OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
     if (! rtti)
     {
         throw RuntimeException(
+#if SUPD == 310
             OUString( RTL_CONSTASCII_USTRINGPARAM("no rtti for type ") ) +
+#else	// SUPD == 310
+            OUString("no rtti for type ") +
+#endif	// SUPD == 310
             *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
             Reference< XInterface >() );
     }
     }
 
-	__cxa_throw( pCppExc, rtti, deleteException );
+    __cxa_throw( pCppExc, rtti, deleteException );
 }
 
 //==================================================================================================
@@ -290,34 +368,50 @@
     if (! header)
     {
         RuntimeException aRE(
+#if SUPD == 310
             OUString( RTL_CONSTASCII_USTRINGPARAM("no exception header!") ),
+#else	// SUPD == 310
+            OUString("no exception header!"),
+#endif	// SUPD == 310
             Reference< XInterface >() );
         Type const & rType = ::getCppuType( &aRE );
         uno_type_any_constructAndConvert( pUnoExc, &aRE, rType.getTypeLibType(), pCpp2Uno );
 #if OSL_DEBUG_LEVEL > 0
         OString cstr( OUStringToOString( aRE.Message, RTL_TEXTENCODING_ASCII_US ) );
+#if SUPD == 310
         OSL_ENSURE( 0, cstr.getStr() );
+#else	// SUPD == 310
+        OSL_FAIL( cstr.getStr() );
+#endif	// SUPD == 310
 #endif
         return;
     }
 
-	typelib_TypeDescription * pExcTypeDescr = 0;
+    typelib_TypeDescription * pExcTypeDescr = 0;
     OUString unoName( toUNOname( header->exceptionType->name() ) );
 #if OSL_DEBUG_LEVEL > 1
     OString cstr_unoName( OUStringToOString( unoName, RTL_TEXTENCODING_ASCII_US ) );
-    fprintf( stderr, "> c++ exception occured: %s\n", cstr_unoName.getStr() );
+    fprintf( stderr, "> c++ exception occurred: %s\n", cstr_unoName.getStr() );
 #endif
-	typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
+    typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
     if (0 == pExcTypeDescr)
     {
         RuntimeException aRE(
+#if SUPD == 310
             OUString( RTL_CONSTASCII_USTRINGPARAM("exception type not found: ") ) + unoName,
+#else	// SUPD == 310
+            OUString("exception type not found: ") + unoName,
+#endif	// SUPD == 310
             Reference< XInterface >() );
         Type const & rType = ::getCppuType( &aRE );
         uno_type_any_constructAndConvert( pUnoExc, &aRE, rType.getTypeLibType(), pCpp2Uno );
 #if OSL_DEBUG_LEVEL > 0
         OString cstr( OUStringToOString( aRE.Message, RTL_TEXTENCODING_ASCII_US ) );
+#if SUPD == 310
         OSL_ENSURE( 0, cstr.getStr() );
+#else	// SUPD == 310
+        OSL_FAIL( cstr.getStr() );
+#endif	// SUPD == 310
 #endif
     }
     else
@@ -330,3 +424,4 @@
 
 }
 
+/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
--- source/cpp_uno/gcc3_macosx_intel/makefile.mk	2008-04-11 03:44:01.000000000 -0700
+++ source/cpp_uno/gcc3_macosx_intel/makefile.mk	2013-09-12 22:20:56.000000000 -0700
@@ -48,6 +48,12 @@
 CFLAGS += -DLEAK_STATIC_DATA
 .ENDIF
 
+.IF "$(BUILD_OS_MAJOR)" == "10" && "$(BUILD_OS_MINOR)" == "6"
+CFLAGS += -DMACOSX_SDK_VERSION=0
+.ELSE		# "$(BUILD_OS_MAJOR)" == "10" && "$(BUILD_OS_MINOR)" == "6"
+CFLAGS += -DMACOSX_SDK_VERSION=1070
+.ENDIF		# "$(BUILD_OS_MAJOR)" == "10" && "$(BUILD_OS_MINOR)" == "6"
+
 CFLAGSNOOPT=-O0
 
 SLOFILES= \
