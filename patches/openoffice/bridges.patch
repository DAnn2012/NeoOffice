--- source/cpp_uno/gcc3_macosx_intel/except.cxx.orig	2008-04-11 03:43:43.000000000 -0700
+++ source/cpp_uno/gcc3_macosx_intel/except.cxx	2013-09-11 21:53:00.000000000 -0700
@@ -33,7 +33,11 @@
 
 #include <stdio.h>
 #include <dlfcn.h>
+
+#if !( defined( __clang__ ) || defined( __llvm__ ) )
 #include <cxxabi.h>
+#endif
+
 #include <hash_map>
 
 #include <rtl/strbuf.hxx>
@@ -59,6 +63,52 @@
 namespace CPPU_CURRENT_NAMESPACE
 {
 
+#if defined( __clang__ ) || defined( __llvm__ )
+namespace {
+
+struct Fake_type_info {
+    virtual ~Fake_type_info() {}
+    char const * name;
+};
+
+struct Fake_class_type_info: Fake_type_info {};
+
+struct Fake_si_class_type_info: Fake_class_type_info {
+    void const * base;
+};
+
+struct Base {};
+struct Derived: Base {};
+
+std::type_info * createFake_class_type_info(char const * name) {
+    char * buf = new char[sizeof (Fake_class_type_info)];
+    *reinterpret_cast<void **>(buf) = *reinterpret_cast<void * const *>(
+        &typeid(Base));
+        // copy __cxxabiv1::__class_type_info vtable into place
+    Fake_class_type_info * fake = reinterpret_cast<Fake_class_type_info *>(buf);
+    fake->name = name;
+    return reinterpret_cast<std::type_info *>(
+        static_cast<Fake_type_info *>(fake));
+}
+
+std::type_info * createFake_si_class_type_info(
+    char const * name, std::type_info const * base)
+{
+    char * buf = new char[sizeof (Fake_si_class_type_info)];
+    *reinterpret_cast<void **>(buf) = *reinterpret_cast<void * const *>(
+        &typeid(Derived));
+        // copy __cxxabiv1::__si_class_type_info vtable into place
+    Fake_si_class_type_info * fake
+        = reinterpret_cast<Fake_si_class_type_info *>(buf);
+    fake->name = name;
+    fake->base = base;
+    return reinterpret_cast<std::type_info *>(
+        static_cast<Fake_type_info *>(fake));
+}
+
+}
+#endif // __clang__
+
 void dummy_can_throw_anything( char const * )
 {
 }
@@ -181,13 +231,21 @@
                     // ensure availability of base
                     type_info * base_rtti = getRTTI(
                         (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
+#if defined( __clang__ ) || defined( __llvm__ )
+                    rtti = createFake_si_class_type_info(rttiName, base_rtti);
+#else
                     rtti = new __si_class_type_info(
                         strdup( rttiName ), (__class_type_info *)base_rtti );
+#endif
                 }
                 else
                 {
                     // this class has no base class
+#if defined( __clang__ ) || defined( __llvm__ )
+                    rtti = createFake_class_type_info(rttiName);
+#else
                     rtti = new __class_type_info( strdup( rttiName ) );
+#endif
                 }
 
                 pair< t_rtti_map::iterator, bool > insertion(
