Index: inc/salgdi.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/Attic/salgdi.hxx,v
retrieving revision 1.36
diff -u -r1.36 salgdi.hxx
--- inc/salgdi.hxx	14 Nov 2006 15:22:46 -0000	1.36
+++ inc/salgdi.hxx	7 May 2007 20:24:38 -0000
@@ -171,6 +171,7 @@
     virtual BOOL        getNativeControlRegion( ControlType nType, ControlPart nPart, const Region& rControlRegion, ControlState nState,
                                                 const ImplControlValue& aValue, SalControlHandle& rControlHandle, const rtl::OUString& aCaption,
                                                 Region &rNativeBoundingRegion, Region &rNativeContentRegion );
+    virtual BOOL        getNativeControlTextColor( ControlType nType, ControlPart nPart, ControlState nState, const ImplControlValue& aValue, SalColor& textColor );
 
     /** Render bitmap with alpha channel
 
@@ -463,6 +464,13 @@
 										 Region &rNativeBoundingRegion,
 										 Region &rNativeContentRegion,
                                          const OutputDevice *pOutDev );
+
+    // Query the VCL implementation for the text color that should be used to draw a native control
+    BOOL GetNativeControlTextColor( ControlType nType, 
+    									 ControlPart nPart, 
+    									 ControlState nState, 
+    									 const ImplControlValue& aValue, 
+    									 Color& textColor );
                                          
     static void AddDevFontSubstitute( OutputDevice* pOutDev,
                                       const String& rFontName,
Index: inc/salnativewidgets.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salnativewidgets.hxx,v
retrieving revision 1.9
diff -u -r1.9 salnativewidgets.hxx
--- inc/salnativewidgets.hxx	19 Jun 2006 19:07:59 -0000	1.9
+++ inc/salnativewidgets.hxx	7 Jan 2007 02:17:52 -0000
@@ -138,6 +138,18 @@
 // tool tips
 #define CTRL_TOOLTIP            140
 
+// progress bars
+#define CTRL_PROGRESSBAR		150
+
+// hierarchical tree control expand/collapse handle
+#define CTRL_DISCLOSUREBTN		160
+
+// list view header cell appearing above columns in lists
+#define CTRL_LISTVIEWHEADER		170
+
+// native frame to draw around list views.  Default is sunken Win95 well.
+#define CTRL_LISTVIEWBOX		180
+
 /* Control Parts:
  *
  *   Uniquely identify a part of a control,
@@ -163,6 +175,7 @@
 #define PART_MENU_ITEM              250
 #define PART_MENU_ITEM_CHECK_MARK   251
 #define PART_MENU_ITEM_RADIO_MARK   252
+#define PART_LISTVIEWHEADER_SORT_MARK	150	// used for list view headers to indicate whether they draw an ascending/descending sort indicator or whether VCL should handle the indicator
 
 /** The edit field part of a control, e.g. of the combo box.
 
@@ -340,6 +353,79 @@
     int             maTopDockingAreaHeight;
 };
 
+/*  ProgressbarValue:
+ *
+ *  Value container for progressbars indicating task completion
+ */
+class ProgressbarValue
+{
+	public:
+		BOOL	mbIndeterminate;	// indcates if the progress bar is indeterminate (unknown action length) or determinate (able to determine completion)
+		double	mdPercentComplete;	// percentage in range [0.0, 100.0], only used for determinate progress bars
+		
+		ProgressbarValue()
+			{
+				mbIndeterminate = FALSE;
+				mdPercentComplete = 0;
+			};
+		
+		~ProgressbarValue() {};
+};
+
+#define DISCLOSUREBTN_CLOSED	0		// group for this control is currently closed, displaying the container only
+#define DISCLOSUREBTN_OPEN		1		// group for this control is currently expanded, displaying all elements within the container
+
+#define DISCLOSUREBTN_ALIGN_LEFT	0	// disclosure controls appear to the left of any items in the left margin of the column
+#define DISCLOSUREBTN_ALIGN_RIGHT	1	// disclosure contorls appear to the right of any items in the right margin of the column
+
+/*	DisclosureBtnValue:
+ *
+ *	Value container for disclosure buttons used for control of expanding/collapsing
+ *	tree views
+ */
+class DisclosureBtnValue
+{
+	public:
+		USHORT mnOpenCloseState;		// indicates whether the controls associated container is open or closed, DISCLOSURE_OPEN/CLOSED
+		USHORT mnAlignment;				// indicates whether the disclosure control appears to the left or right of containers
+		BOOL mbHasChildren;				// true if the node has any children, false if not
+		
+		DisclosureBtnValue()
+			{
+				mnOpenCloseState = DISCLOSUREBTN_CLOSED;
+				mnAlignment = DISCLOSUREBTN_ALIGN_LEFT;
+				mbHasChildren = 1;
+			};
+		
+		~DisclosureBtnValue() {};
+};
+
+#define LISTVIEWHEADER_SORT_DONTKNOW	0	// indicates the current sort of the column is unknown
+#define LISTVIEWHEADER_SORT_DESCENDING	1	// indicates the column is sorted in descending order
+#define LISTVIEWHEADER_SORT_ASCENDING	2	// indicates the column is sorted in ascending order
+#define LISTVIEWHEADER_SORT_UNSORTED	3	// indicates the column is not sorted
+
+/*	ListViewHeaderValue
+ *
+ *	Value container for list view header cells drawn above columns of scrollable
+ *	lists.  Indicates whether the clumn is the primary sort column and
+ *	any direction of the sort
+ */
+class ListViewHeaderValue
+{
+	public:
+		BOOL mbPrimarySortColumn;		// true if the column is the primary active column on which data is sorted, false if it is a secondary informational column
+		USHORT mnSortDirection;			// sort direction for the column.
+		
+		ListViewHeaderValue()
+			{
+				mbPrimarySortColumn = FALSE;
+				mnSortDirection = LISTVIEWHEADER_SORT_DONTKNOW;
+			};
+		
+		~ListViewHeaderValue() {};
+};
+
 /* ImplControlValue:
  *
  *   Generic value container for all control parts.
--- inc/window.hxx	2006-10-12 07:57:43.000000000 -0700
+++ inc/window.hxx	2007-01-20 14:50:43.000000000 -0800
@@ -1079,6 +1079,13 @@
 										  Region &rNativeBoundingRegion,
 										  Region &rNativeContentRegion );
 
+    // Query the VCL implementation for the text color that should be used to draw a native control
+    BOOL GetNativeControlTextColor( ControlType nType, 
+    									 ControlPart nPart, 
+    									 ControlState nState, 
+    									 const ImplControlValue& aValue, 
+    									 Color& textColor );
+
     // a helper method for a Control's Draw method
     void PaintToDevice( OutputDevice* pDevice, const Point& rPos, const Size& rSize );
 };
--- source/gdi/salgdilayout.cxx	2006-09-17 05:10:36.000000000 -0700
+++ source/gdi/salgdilayout.cxx	2007-01-20 15:26:56.000000000 -0800
@@ -620,6 +620,19 @@
                                                 rNativeBoundingRegion, rNativeContentRegion );
 }
 
+BOOL SalGraphics::GetNativeControlTextColor( ControlType nType, 
+									 ControlPart nPart, 
+									 ControlState nState, 
+									 const ImplControlValue& aValue, 
+									 Color& textColor )
+{
+	SalColor aSalColor;
+	BOOL bRet = getNativeControlTextColor( nType, nPart, nState, aValue, aSalColor );
+	if ( bRet )
+		textColor = Color( aSalColor );
+	return bRet;
+}
+
 bool SalGraphics::filterText( const String&, String&, xub_StrLen, xub_StrLen&, xub_StrLen&, xub_StrLen& )
 {
     return false;
Index: source/gdi/salnativewidgets-none.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/salnativewidgets-none.cxx,v
retrieving revision 1.5
diff -u -r1.5 salnativewidgets-none.cxx
--- source/gdi/salnativewidgets-none.cxx	17 Sep 2006 12:11:27 -0000	1.5
+++ source/gdi/salnativewidgets-none.cxx	7 Jan 2007 02:17:53 -0000
@@ -147,3 +147,17 @@
 	return( FALSE );
 }
 
+/*
+ * getNativeControlTextColor()
+ *
+ *  If the return value is TRUE, textColor contains the color with which the text
+ *	should be drawn given the control state and other values.  If the return value
+ *	is FALSE, the control text should be drawn with the platform independent Sal
+ *	control colors returned by each SalApplication derivative.
+ *
+ *  aValue:		An optional value (tristate/numerical/string)
+ */
+BOOL SalGraphics::getNativeControlTextColor(  ControlType nType, ControlPart nPart, ControlState nState, const ImplControlValue& aValue, SalColor& textColor )
+{
+	return( FALSE );
+}
--- source/window/window3.cxx	2006-09-17 05:24:10.000000000 -0700
+++ source/window/window3.cxx	2007-01-20 14:50:41.000000000 -0800
@@ -312,6 +312,29 @@
 
 // -----------------------------------------------------------------------
 
+BOOL Window::GetNativeControlTextColor( ControlType nType, 
+									 ControlPart nPart, 
+									 ControlState nState, 
+									 const ImplControlValue& aValue, 
+									 Color& textColor )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    ImplInitSalControlHandle();
+	
+	BOOL bRet = mpGraphics->GetNativeControlTextColor(nType, nPart, nState, aValue, textColor);
+	
+	return bRet;
+}
+
+
+// -----------------------------------------------------------------------
+
 WaitObject::~WaitObject()
 {
     if ( mpWindow )
Index: util/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/util/makefile.mk,v
retrieving revision 1.82
diff -u -r1.82 makefile.mk
--- util/makefile.mk	6 Oct 2006 10:07:49 -0000	1.82
+++ util/makefile.mk	7 Jan 2007 02:17:54 -0000
@@ -185,6 +185,13 @@
     SHL1STDLIBS+=   $(FREETYPELIB)
 .ENDIF # USE_BUILTIN_RASTERIZER
 
+.IF "$(OS)"=="MACOSX"
+SHL1STDLIBS += -framework CoreFoundation
+.IF "$(GUI)"=="UNX"
+SHL1STDLIBS += -lX11
+.ENDIF		# "$(GUI)"=="UNX"
+.ENDIF		# "$(OS)"=="MACOSX"
+
 SHL1LIBS=   $(LIB1TARGET)
 .IF "$(GUI)"!="UNX"
 SHL1OBJS=   $(SLO)$/salshl.obj
@@ -275,7 +275,7 @@
 .IF "$(USE_XINERAMA)" != "NO"
 
 .IF "$(OS)"=="MACOSX"
-XINERAMALIBS=-lXinerama
+XINERAMALIBS= /usr/X11R6/lib/libXinerama.a
 .ELSE
 .IF "$(OS)" != "SOLARIS" || "$(USE_XINERAMA_VERSION)" == "Xorg"
 .IF "$(XINERAMA_LINK)" == "dynamic"
--- inc/cmdevt.hxx	2006-07-14 01:53:15.000000000 -0700
+++ inc/cmdevt.hxx	2007-02-13 00:00:31.000000000 -0800
@@ -181,7 +182,7 @@
                         { return ((mnCode & KEY_MOD1) != 0); }
     BOOL            IsMod2() const
                         { return ((mnCode & KEY_MOD2) != 0); }
-#ifdef MACOSX
+#ifdef USE_REJECTED_MACOSX
     BOOL	    IsMod5() const
 			{ return ((mnCode & KEY_MOD5) != 0); }
 #endif
--- inc/keycod.hxx	2007-01-24 07:07:15.000000000 -0800
+++ inc/keycod.hxx	2007-07-01 10:48:07.000000000 -0700
@@ -95,7 +96,7 @@
 				KeyCode( KeyFuncType eFunction );
 
 	USHORT		GetFullCode() const { return nCode; }
-#ifdef MACOSX
+#ifdef USE_REJECTED_MACOSX
 	USHORT		GetFullKeyCode() const { return (nCode) ; }
 #else
 	USHORT		GetFullKeyCode() const { return (nCode & ~KEY_CONTROLMOD); }
@@ -116,7 +117,7 @@
 					{ return ((nCode & KEY_MOD1) != 0); }
 	BOOL		IsMod2() const
 					{ return ((nCode & KEY_MOD2) != 0); }
-#ifdef MACOSX
+#ifdef USE_REJECTED_MACOSX
 	//  [ericb 07/2006]] Remap ALT with mod5, working fine with Tiger
 	BOOL		IsMod5() const
 					{ return ((nCode & KEY_MOD5) != 0); }	
--- inc/keycodes.hxx	2006-07-14 01:53:48.000000000 -0700
+++ inc/keycodes.hxx	2007-02-13 00:00:31.000000000 -0800
@@ -178,7 +179,7 @@
 #define KEY_SHIFT		((USHORT)0x1000)
 #define KEY_MOD1		((USHORT)0x2000)
 #define KEY_MOD2		((USHORT)0x4000)
-#ifdef MACOSX
+#ifdef USE_REJECTED_MACOSX
 #define KEY_MOD5	((USHORT)0x8000)
 #define KEY_MODTYPE	((USHORT)0xF000)
 #else
--- source/window/keycod.cxx	2006-09-17 05:19:13.000000000 -0700
+++ source/window/keycod.cxx	2007-02-13 00:00:33.000000000 -0800
@@ -63,7 +64,7 @@
 
 
 // =======================================================================
-#ifdef MACOSX
+#ifdef USE_REJECTED_MACOSX
 static USHORT aImplKeyFuncTab[(KEYFUNC_FRONT+1)*3] =
 {
 	0, 0, 0,												// KEYFUNC_DONTKNOW
--- source/window/winproc.cxx	2006-10-13 01:33:12.000000000 -0700
+++ source/window/winproc.cxx	2007-02-13 00:00:33.000000000 -0800
@@ -645,7 +646,7 @@
                                 // create a uno mouse event out of the available data
                                 ::com::sun::star::awt::MouseEvent aMouseEvent(
                                     static_cast < ::com::sun::star::uno::XInterface * > ( 0 ),
-#ifdef MACOSX
+#ifdef USE_REJECTED_MACOSX
 				    nCode & (KEY_SHIFT | KEY_MOD1 | KEY_MOD2 | KEY_MOD5),
 #else
                                     nCode & (KEY_SHIFT | KEY_MOD1 | KEY_MOD2),
@@ -2084,7 +2085,7 @@
     return ImplHandleMouseEvent( pWindow, EVENT_MOUSEBUTTONDOWN, FALSE,
                                  pEvent->mnX, pEvent->mnY,
                                  pEvent->mnTime,
-#ifdef MACOSX
+#ifdef USE_REJECTED_MACOSX
 				 pEvent->mnButton | (pEvent->mnCode & (KEY_SHIFT | KEY_MOD1 | KEY_MOD2 | KEY_MOD5)),
 #else
                                  pEvent->mnButton | (pEvent->mnCode & (KEY_SHIFT | KEY_MOD1 | KEY_MOD2)),
@@ -2099,7 +2100,7 @@
     return ImplHandleMouseEvent( pWindow, EVENT_MOUSEBUTTONUP, FALSE,
                                  pEvent->mnX, pEvent->mnY,
                                  pEvent->mnTime,
-#ifdef MACOSX
+#ifdef USE_REJECTED_MACOSX
 				 pEvent->mnButton | (pEvent->mnCode & (KEY_SHIFT | KEY_MOD1 | KEY_MOD2 | KEY_MOD5)),
 #else
                                  pEvent->mnButton | (pEvent->mnCode & (KEY_SHIFT | KEY_MOD1 | KEY_MOD2)),
@@ -2162,7 +2163,7 @@
     Window* pTrackWin = pSVData->maWinData.mpTrackWin;
     if ( pTrackWin )
         pWindow = pTrackWin;
-#ifdef MACOSX
+#ifdef USE_REJECTED_MACOSX
     USHORT nOldCode = pWindow->ImplGetWindowImpl()->mpFrameData->mnMouseCode & (KEY_SHIFT | KEY_MOD1 | KEY_MOD2 | KEY_MOD5);
 #else
     USHORT nOldCode = pWindow->ImplGetWindowImpl()->mpFrameData->mnMouseCode & (KEY_SHIFT | KEY_MOD1 | KEY_MOD2);
@@ -2170,7 +2171,7 @@
     USHORT nNewCode = pEvent->mnCode;
     if ( nOldCode != nNewCode )
     {
-#ifdef MACOSX
+#ifdef USE_REJECTED_MACOSX
 	nNewCode |= pWindow->ImplGetWindowImpl()->mpFrameData->mnMouseCode & ~(KEY_SHIFT | KEY_MOD1 | KEY_MOD2 | KEY_MOD5);
 #else
         nNewCode |= pWindow->ImplGetWindowImpl()->mpFrameData->mnMouseCode & ~(KEY_SHIFT | KEY_MOD1 | KEY_MOD2);
