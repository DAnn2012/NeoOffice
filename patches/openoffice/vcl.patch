Index: inc/vcl/salgdi.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/vcl/salgdi.hxx,v
retrieving revision 1.5
diff -u -r1.5 salgdi.hxx
--- inc/vcl/salgdi.hxx	11 Apr 2008 07:53:59 -0000	1.5
+++ inc/vcl/salgdi.hxx	10 Jun 2008 20:57:03 -0000
@@ -155,6 +155,7 @@
     virtual BOOL        getNativeControlRegion( ControlType nType, ControlPart nPart, const Region& rControlRegion, ControlState nState,
                                                 const ImplControlValue& aValue, SalControlHandle& rControlHandle, const rtl::OUString& aCaption,
                                                 Region &rNativeBoundingRegion, Region &rNativeContentRegion );
+    virtual BOOL        getNativeControlTextColor( ControlType nType, ControlPart nPart, ControlState nState, const ImplControlValue& aValue, SalColor& textColor );
 
     /** Render bitmap with alpha channel
 
@@ -459,6 +460,13 @@
 										 Region &rNativeContentRegion,
                                          const OutputDevice *pOutDev );
 
+	// Query the VCL implementation for the text color that should be used to draw a native control
+	BOOL GetNativeControlTextColor( ControlType nType,
+										 ControlPart nPart,
+										 ControlState nState,
+										 const ImplControlValue& aValue,
+										 Color& textColor );
+
     static void AddDevFontSubstitute( OutputDevice* pOutDev,
                                       const String& rFontName,
                                       const String& rReplaceFontName,
Index: inc/vcl/salnativewidgets.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/vcl/salnativewidgets.hxx,v
retrieving revision 1.9
diff -u -r1.9 salnativewidgets.hxx
--- inc/vcl/salnativewidgets.hxx	19 Jun 2006 19:07:59 -0000	1.9
+++ inc/vcl/salnativewidgets.hxx	7 Jan 2007 02:17:52 -0000
@@ -138,6 +138,15 @@
 #define CTRL_LISTNET            171
 
 
+// hierarchical tree control expand/collapse handle
+#define CTRL_DISCLOSUREBTN		230
+
+// list view header cell appearing above columns in lists
+#define CTRL_LISTVIEWHEADER		240
+
+// native frame to draw around list views.  Default is sunken Win95 well.
+#define CTRL_LISTVIEWBOX		250
+
 /* Control Parts:
  *
  *   Uniquely identify a part of a control,
@@ -163,6 +172,7 @@
 #define PART_MENU_ITEM              250
 #define PART_MENU_ITEM_CHECK_MARK   251
 #define PART_MENU_ITEM_RADIO_MARK   252
+#define PART_LISTVIEWHEADER_SORT_MARK	150	// used for list view headers to indicate whether they draw an ascending/descending sort indicator or whether VCL should handle the indicator
 
 /** The edit field part of a control, e.g. of the combo box.
 
@@ -340,6 +350,79 @@
     int             maTopDockingAreaHeight;
 };
 
+/*  ProgressbarValue:
+ *
+ *  Value container for progressbars indicating task completion
+ */
+class ProgressbarValue
+{
+	public:
+		BOOL	mbIndeterminate;	// indcates if the progress bar is indeterminate (unknown action length) or determinate (able to determine completion)
+		double	mdPercentComplete;	// percentage in range [0.0, 100.0], only used for determinate progress bars
+		
+		ProgressbarValue()
+			{
+				mbIndeterminate = FALSE;
+				mdPercentComplete = 0;
+			};
+		
+		~ProgressbarValue() {};
+};
+
+#define DISCLOSUREBTN_CLOSED	0		// group for this control is currently closed, displaying the container only
+#define DISCLOSUREBTN_OPEN		1		// group for this control is currently expanded, displaying all elements within the container
+
+#define DISCLOSUREBTN_ALIGN_LEFT	0	// disclosure controls appear to the left of any items in the left margin of the column
+#define DISCLOSUREBTN_ALIGN_RIGHT	1	// disclosure contorls appear to the right of any items in the right margin of the column
+
+/*	DisclosureBtnValue:
+ *
+ *	Value container for disclosure buttons used for control of expanding/collapsing
+ *	tree views
+ */
+class DisclosureBtnValue
+{
+	public:
+		USHORT mnOpenCloseState;		// indicates whether the controls associated container is open or closed, DISCLOSURE_OPEN/CLOSED
+		USHORT mnAlignment;				// indicates whether the disclosure control appears to the left or right of containers
+		BOOL mbHasChildren;				// true if the node has any children, false if not
+		
+		DisclosureBtnValue()
+			{
+				mnOpenCloseState = DISCLOSUREBTN_CLOSED;
+				mnAlignment = DISCLOSUREBTN_ALIGN_LEFT;
+				mbHasChildren = 1;
+			};
+		
+		~DisclosureBtnValue() {};
+};
+
+#define LISTVIEWHEADER_SORT_DONTKNOW	0	// indicates the current sort of the column is unknown
+#define LISTVIEWHEADER_SORT_DESCENDING	1	// indicates the column is sorted in descending order
+#define LISTVIEWHEADER_SORT_ASCENDING	2	// indicates the column is sorted in ascending order
+#define LISTVIEWHEADER_SORT_UNSORTED	3	// indicates the column is not sorted
+
+/*	ListViewHeaderValue
+ *
+ *	Value container for list view header cells drawn above columns of scrollable
+ *	lists.  Indicates whether the clumn is the primary sort column and
+ *	any direction of the sort
+ */
+class ListViewHeaderValue
+{
+	public:
+		BOOL mbPrimarySortColumn;		// true if the column is the primary active column on which data is sorted, false if it is a secondary informational column
+		USHORT mnSortDirection;			// sort direction for the column.
+		
+		ListViewHeaderValue()
+			{
+				mbPrimarySortColumn = FALSE;
+				mnSortDirection = LISTVIEWHEADER_SORT_DONTKNOW;
+			};
+		
+		~ListViewHeaderValue() {};
+};
+
 /*	PushButtonValue:
  *
  *  Value container for pushbuttons specifying additional drawing hints
Index: inc/vcl/window.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/vcl/window.hxx,v
retrieving revision 1.8
diff -u -r1.8 window.hxx
--- inc/vcl/window.hxx	11 Apr 2008 08:09:51 -0000	1.8
+++ inc/vcl/window.hxx	10 Jun 2008 21:01:20 -0000
@@ -1118,6 +1118,13 @@
 										  Region &rNativeBoundingRegion,
 										  Region &rNativeContentRegion );
 
+    // Query the VCL implementation for the text color that should be used to draw a native control
+    BOOL GetNativeControlTextColor( ControlType nType,
+										  ControlPart nPart,
+										  ControlState nState,
+										  const ImplControlValue& aValue,
+										  Color& textColor );
+
     // a helper method for a Control's Draw method
     void PaintToDevice( OutputDevice* pDevice, const Point& rPos, const Size& rSize );
     
--- source/gdi/salgdilayout.cxx	2006-09-17 05:10:36.000000000 -0700
+++ source/gdi/salgdilayout.cxx	2007-01-20 15:26:56.000000000 -0800
@@ -620,6 +620,19 @@
 	return drawAlphaRect( nX, nY, nWidth, nHeight, nTransparency );
 }
 
+BOOL SalGraphics::GetNativeControlTextColor( ControlType nType, 
+									 ControlPart nPart, 
+									 ControlState nState, 
+									 const ImplControlValue& aValue, 
+									 Color& textColor )
+{
+	SalColor aSalColor;
+	BOOL bRet = getNativeControlTextColor( nType, nPart, nState, aValue, aSalColor );
+	if ( bRet )
+		textColor = Color( aSalColor );
+	return bRet;
+}
+
 bool SalGraphics::filterText( const String&, String&, xub_StrLen, xub_StrLen&, xub_StrLen&, xub_StrLen& )
 {
     return false;
Index: source/gdi/salnativewidgets-none.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/salnativewidgets-none.cxx,v
retrieving revision 1.5
diff -u -r1.5 salnativewidgets-none.cxx
--- source/gdi/salnativewidgets-none.cxx	17 Sep 2006 12:11:27 -0000	1.5
+++ source/gdi/salnativewidgets-none.cxx	7 Jan 2007 02:17:53 -0000
@@ -147,3 +147,17 @@
 	return( FALSE );
 }
 
+/*
+ * getNativeControlTextColor()
+ *
+ *  If the return value is TRUE, textColor contains the color with which the text
+ *	should be drawn given the control state and other values.  If the return value
+ *	is FALSE, the control text should be drawn with the platform independent Sal
+ *	control colors returned by each SalApplication derivative.
+ *
+ *  aValue:		An optional value (tristate/numerical/string)
+ */
+BOOL SalGraphics::getNativeControlTextColor(  ControlType nType, ControlPart nPart, ControlState nState, const ImplControlValue& aValue, SalColor& textColor )
+{
+	return( FALSE );
+}
--- source/window/window3.cxx	2006-09-17 05:24:10.000000000 -0700
+++ source/window/window3.cxx	2007-01-20 14:50:41.000000000 -0800
@@ -312,6 +312,29 @@
 
 // -----------------------------------------------------------------------
 
+BOOL Window::GetNativeControlTextColor( ControlType nType, 
+									 ControlPart nPart, 
+									 ControlState nState, 
+									 const ImplControlValue& aValue, 
+									 Color& textColor )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    ImplInitSalControlHandle();
+	
+	BOOL bRet = mpGraphics->GetNativeControlTextColor(nType, nPart, nState, aValue, textColor);
+	
+	return bRet;
+}
+
+
+// -----------------------------------------------------------------------
+
 WaitObject::~WaitObject()
 {
     if ( mpWindow )
--- util/makefile.mk	2009-01-05 06:44:12.000000000 -0800
+++ util/makefile.mk	2011-02-02 07:43:41.000000000 -0800
@@ -190,6 +190,7 @@
 	-lAppleRemote$(DLLPOSTFIX)
 
 SHL1STDLIBS+= \
+             -framework Carbon \
              -framework QTKit
 LIB1FILES+= \
             $(SLB)$/sala11y.lib
--- aqua/source/a11y/aqua11yfocuslistener.hxx	2008-04-15 06:10:39.000000000 -0700
+++ aqua/source/a11y/aqua11yfocuslistener.hxx	2012-07-12 21:53:03.000000000 -0700
@@ -47,8 +47,8 @@
     
     static rtl::Reference< AquaA11yFocusListener > theListener;
 
-    AquaA11yFocusListener::AquaA11yFocusListener();
-    virtual AquaA11yFocusListener::~AquaA11yFocusListener() {};
+    AquaA11yFocusListener();
+    virtual ~AquaA11yFocusListener() {};
 public:
 
     static rtl::Reference< AquaA11yFocusListener > get();
@@ -63,4 +63,4 @@
     virtual oslInterlockedCount SAL_CALL release() SAL_THROW(());	
 };
 
-#endif // _AQUA11YFOCUSLISTENER_HXX_
\ No newline at end of file
+#endif // _AQUA11YFOCUSLISTENER_HXX_
--- aqua/inc/salgdi.h	2008-12-02 03:03:18.000000000 -0800
+++ aqua/inc/salgdi.h	2014-04-27 20:55:36.000000000 -0700
@@ -84,11 +84,11 @@
 public:
 	RGBAColor( SalColor );
 	RGBAColor( float fRed, float fGreen, float fBlue, float fAlpha ); //NOTUSEDYET
-	const float* AsArray() const	{ return &mfRed; }
+	const CGFloat* AsArray() const	{ return &mfRed; }
 	bool IsVisible() const			{ return (mfAlpha > 0); }
 	void SetAlpha( float fAlpha )	{ mfAlpha = fAlpha; }
 private:
-	float mfRed, mfGreen, mfBlue, mfAlpha;
+	CGFloat mfRed, mfGreen, mfBlue, mfAlpha;
 };
 
 // -------------------
@@ -170,7 +170,9 @@
     bool                CheckContext();
     void                UpdateWindow( NSRect& ); // delivered in NSView coordinates
 	void				RefreshRect( const CGRect& );
+#if SUPD != 310
 	void				RefreshRect( const NSRect& );
+#endif	// SUPD != 310
 	void				RefreshRect(float lX, float lY, float lWidth, float lHeight);
 
     void                SetState();
@@ -185,11 +187,11 @@
     virtual void		drawRect( long nX, long nY, long nWidth, long nHeight );
     virtual void		drawPolyLine( ULONG nPoints, const SalPoint* pPtAry );
     virtual void		drawPolygon( ULONG nPoints, const SalPoint* pPtAry );
-    virtual void		drawPolyPolygon( ULONG nPoly, const ULONG* pPoints, PCONSTSALPOINT* pPtAry );
+    virtual void		drawPolyPolygon( sal_uInt32 nPoly, const sal_uInt32* pPoints, PCONSTSALPOINT* pPtAry );
     virtual bool        drawPolyPolygon( const ::basegfx::B2DPolyPolygon&, double fTransparency );
     virtual sal_Bool	drawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry );
     virtual sal_Bool	drawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry );
-    virtual sal_Bool	drawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints, const SalPoint* const* pPtAry, const BYTE* const* pFlgAry );
+    virtual sal_Bool	drawPolyPolygonBezier( sal_uInt32 nPoly, const sal_uInt32* pPoints, const SalPoint* const* pPtAry, const BYTE* const* pFlgAry );
     virtual bool        drawPolyLine( const ::basegfx::B2DPolygon&, const ::basegfx::B2DVector& rLineWidths, basegfx::B2DLineJoin);
 
     // CopyArea --> No RasterOp, but ClipRegion
@@ -241,7 +243,7 @@
                                                 Region &rNativeBoundingRegion, Region &rNativeContentRegion );
 
     // get device resolution
-    virtual void			GetResolution( long& rDPIX, long& rDPIY );
+    virtual void			GetResolution( sal_Int32& rDPIX, sal_Int32& rDPIY );
     // get the depth of the device
     virtual USHORT			GetBitCount();
     // get the width of the device
@@ -301,7 +303,7 @@
     // as "undefined character"
     virtual BOOL			CreateFontSubset( const rtl::OUString& rToFile,
                                               const ImplFontData* pFont,
-                                              long* pGlyphIDs,
+                                              sal_Int32* pGlyphIDs,
                                               sal_uInt8* pEncoding,
                                               sal_Int32* pWidths,
                                               int nGlyphs,
@@ -391,11 +393,15 @@
 	RefreshRect( rRect.origin.x, rRect.origin.y, rRect.size.width, rRect.size.height );
 }
 
+#if SUPD != 310
+
 inline void AquaSalGraphics::RefreshRect( const NSRect& rRect )
 {
 	RefreshRect( rRect.origin.x, rRect.origin.y, rRect.size.width, rRect.size.height );
 }
 
+#endif	// SUPD != 310
+
 inline RGBAColor::RGBAColor( SalColor nSalColor )
 :	mfRed( SALCOLOR_RED(nSalColor) * (1.0/255))
 ,	mfGreen( SALCOLOR_GREEN(nSalColor) * (1.0/255))
--- aqua/source/a11y/aqua11ytextattributeswrapper.mm	2008-04-17 00:06:11.000000000 -0700
+++ aqua/source/a11y/aqua11ytextattributeswrapper.mm	2014-04-27 17:09:30.000000000 -0700
@@ -110,7 +110,7 @@
 
 +(void)addColor:(sal_Int32)salColor forAttribute:(NSString *)attribute andRange:(NSRange)range toString:(NSMutableAttributedString *)string {
     if ( salColor != -1 ) {
-        float elements[] = { salColor & 0x00ff0000, salColor & 0x0000ff00, salColor & 0x000000ff };
+        CGFloat elements[] = { salColor & 0x00ff0000, salColor & 0x0000ff00, salColor & 0x000000ff };
         CGColorRef color = CGColorCreate ( CGColorSpaceCreateWithName ( kCGColorSpaceGenericRGB ), elements );
         [ string addAttribute: attribute value: (id) color range: range ];
         CGColorRelease ( color );
--- aqua/source/gdi/salatslayout.cxx	2009-07-27 06:48:22.000000000 -0700
+++ aqua/source/gdi/salatslayout.cxx	2014-04-27 20:37:55.000000000 -0700
@@ -50,9 +50,9 @@
 						sal_Int32* pGlyphAdvances, int* pCharIndexes ) const;
 
 	virtual long    GetTextWidth() const;
-	virtual long    FillDXArray( long* pDXArray ) const;
+	virtual long    FillDXArray( sal_Int32* pDXArray ) const;
 	virtual int     GetTextBreak( long nMaxWidth, long nCharExtra, int nFactor ) const;
-	virtual void    GetCaretPositions( int nArraySize, long* pCaretXArray ) const;
+	virtual void    GetCaretPositions( int nArraySize, sal_Int32* pCaretXArray ) const;
 	virtual bool    GetGlyphOutlines( SalGraphics&, PolyPolyVector& ) const;
 	virtual bool    GetBoundRect( SalGraphics&, Rectangle& ) const;
 
@@ -432,6 +432,7 @@
 		}
 	}
 
+#if SUPD != 310
 	// request an update of the changed window area
 	if( rAquaGraphics.IsWindowGraphics() )
 	{
@@ -452,6 +453,7 @@
 			rAquaGraphics.RefreshRect( aRect );
         }
 	}
+#endif	// SUPD != 310
 
     // restore the original graphic context transformations
 	CGContextRestoreGState( rAquaGraphics.mrContext );
@@ -663,7 +665,7 @@
  *
  * @return : typographical width of the complete text layout
 **/
-long ATSLayout::FillDXArray( long* pDXArray ) const
+long ATSLayout::FillDXArray( sal_Int32* pDXArray ) const
 {
     // short circuit requests which don't need full details
     if( !pDXArray )
@@ -716,6 +718,9 @@
 	// check assumptions
 	DBG_ASSERT( !nTrailingSpaceWidth, "ATSLayout::GetTextBreak() with nTSW!=0" );
 
+#if SUPD == 310
+	return STRING_LEN;
+#else	// SUPD == 310
 	// initial measurement of text break position
 	UniCharArrayOffset nBreakPos = mnMinCharPos;
     const ATSUTextMeasurement nATSUMaxWidth = Vcl2Fixed( nPixelWidth ); 
@@ -771,6 +776,7 @@
 	UniCharArrayOffset nBreakPosInWord = nBreakPos;
 	nStatus = ATSUBreakLine( maATSULayout, nBreakPos, nATSURemWidth, false, &nBreakPosInWord );
 	return nBreakPosInWord;
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
@@ -783,7 +789,7 @@
  *
  * @return : none	
 **/
-void ATSLayout::GetCaretPositions( int nMaxIndex, long* pCaretXArray ) const
+void ATSLayout::GetCaretPositions( int nMaxIndex, sal_Int32* pCaretXArray ) const
 {
 	DBG_ASSERT( ((nMaxIndex>0)&&!(nMaxIndex&1)),
 		"ATSLayout::GetCaretPositions() : invalid number of caret pairs requested");
@@ -792,6 +798,7 @@
     for( int i = 0; i < nMaxIndex; ++i )
         pCaretXArray[ i ] = -1;
 
+#if SUPD != 310
 	for( int n = 0; n <= mnCharCount; ++n )
 	{
 		// measure the characters cursor position
@@ -815,6 +822,7 @@
 			break;
 		pCaretXArray[2*n+0] = nPixelPos;
 	}
+#endif	// SUPD != 310
 }
 
 // -----------------------------------------------------------------------
@@ -829,6 +837,9 @@
 **/
 bool ATSLayout::GetBoundRect( SalGraphics&, Rectangle& rVCLRect ) const
 {
+#if SUPD == 310
+	return false;
+#else	// SUPD == 310
 	const Point aPos = GetDrawPosition( Point(mnBaseAdv, 0) );
 	const Fixed nFixedX = Vcl2Fixed( +aPos.X() );
 	const Fixed nFixedY = Vcl2Fixed( +aPos.Y() );
@@ -845,6 +856,7 @@
 	rVCLRect.Right()  = AtsuPix2Vcl( aMacRect.right );
 	rVCLRect.Bottom() = AtsuPix2Vcl( aMacRect.bottom );
 	return true;
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
@@ -878,6 +890,9 @@
 	}
 
 	// get details about the glyph layout
+#if SUPD == 310
+	return false;
+#else	// SUPD == 310
 	ItemCount iLayoutDataCount;
 	const ATSLayoutRecord* pALR;
 	OSStatus eStatus = ATSUDirectGetLayoutDataArrayPtrFromTextLayout(
@@ -991,12 +1006,16 @@
 		kATSUDirectDataLayoutRecordATSLayoutRecordCurrent, (void**)&pALR );
 
 	return true;
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
 
 bool ATSLayout::GetIdealX() const
 {
+#if SUPD == 310
+	return false;
+#else	// SUPD == 310
 	// compute the ideal advance widths only once
 	if( mpGlyphOrigAdvs != NULL )
 		return true;
@@ -1018,12 +1037,16 @@
 		mpGlyphOrigAdvs[i] = FloatToFixed( aIdealMetrics[i].advance.x );
 
 	return true;
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
 
 bool ATSLayout::GetDeltaY() const
 {
+#if SUPD == 310
+	return false;
+#else	// SUPD == 310
 	// don't bother to get the same delta-y-array more than once
 	if( mpDeltaY != NULL )
 		return true;
@@ -1057,6 +1080,7 @@
 #endif
 	
 	return true;
+#endif	// SUPD == 310
 }
 
 // =======================================================================
--- aqua/source/gdi/salatsuifontutils.cxx	2008-10-01 07:46:45.000000000 -0700
+++ aqua/source/gdi/salatsuifontutils.cxx	2014-04-27 20:24:56.000000000 -0700
@@ -174,6 +174,9 @@
 
 static bool GetDevFontAttributes( ATSUFontID nFontID, ImplDevFontAttributes& rDFA )
 {
+#if SUPD == 310
+    return false;
+#else	// SUPD == 310
     // all ATSU fonts are device fonts that can be directly rotated
     rDFA.mbOrientation = true;
     rDFA.mbDevice      = true;
@@ -392,12 +395,16 @@
 
     bool bRet = (rDFA.maName.Len() > 0);
     return bRet;
+#endif	// SUPD == 310
 }
 
 // =======================================================================
 
 SystemFontList::SystemFontList()
 {
+#if SUPD == 310
+    return;
+#else	// SUPD == 310
     // count available system fonts
     ItemCount nATSUICompatibleFontsAvailable = 0;
     if( ATSUFontCount(&nATSUICompatibleFontsAvailable) != noErr )
@@ -427,6 +434,7 @@
     }
 
     InitGlyphFallbacks();
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
@@ -438,7 +446,9 @@
         delete (*it).second;
     maFontContainer.clear();
 
+#if SUPD != 310
     ATSUDisposeFontFallbacks( maFontFallbacks );
+#endif	// SUPD != 310
 }
 
 // -----------------------------------------------------------------------
@@ -511,9 +521,11 @@
         aFallbackVector.push_back( nFontID );
     }
 
+#if SUPD != 310
     ATSUCreateFontFallbacks( &maFontFallbacks );
     ATSUSetObjFontFallbacks( maFontFallbacks,
 		aFallbackVector.size(), &aFallbackVector[0], kATSUSequentialFallbacksPreferred );
+#endif	// SUPD != 310
 }
 
 // -----------------------------------------------------------------------
--- aqua/source/gdi/salbmp.cxx	2008-12-01 06:29:22.000000000 -0800
+++ aqua/source/gdi/salbmp.cxx	2014-04-27 20:57:58.000000000 -0700
@@ -766,7 +766,7 @@
 	    CFRelease( xMask );
 		CGDataProviderRef xDataProvider( CGDataProviderCreateWithData( NULL,
 		pMaskMem, nHeight * nMaskBytesPerRow, &CFRTLFree ) );
-		static const float* pDecode = NULL;
+		static const CGFloat* pDecode = NULL;
 		xMask = CGImageMaskCreate( nWidth, nHeight, 8, 8, nMaskBytesPerRow, xDataProvider, pDecode, false );
 		CFRelease( xDataProvider );
 		CFRelease( xMaskContext );
--- aqua/source/gdi/salgdi.cxx	2009-07-17 00:24:42.000000000 -0700
+++ aqua/source/gdi/salgdi.cxx	2014-04-27 21:01:01.000000000 -0700
@@ -126,6 +126,9 @@
 	// set the default charmap
 	mpCharMap = ImplFontCharMap::GetDefaultMap();
 
+#if SUPD == 310
+	return mpCharMap;
+#else 	// SUPD == 310
 	// get the CMAP byte size
 	ATSFontRef rFont = FMGetATSFontRefFromFont( mnFontId );
 	ByteCount nBufSize = 0;
@@ -152,12 +155,16 @@
 
 	mpCharMap = new ImplFontCharMap( aCmapResult.mnPairCount, aCmapResult.mpPairCodes, aCmapResult.mpStartGlyphs );
 	return mpCharMap;
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
 
 void ImplMacFontData::ReadOs2Table( void ) const
 {
+#if SUPD == 310
+	return;
+#else	// SUPD == 310
 	// read this only once per font
 	if( mbOs2Read )
 		return;
@@ -196,10 +203,14 @@
         if( ulUnicodeRange2 & 0x2DF00000 )
             mbHasCJKSupport = true;
     }
+#endif	// SUPD == 310
 }
 
 void ImplMacFontData::ReadMacCmapEncoding( void ) const
 {
+#if SUPD == 310
+    return;
+#else	// SUPD == 310
     // read this only once per font
     if( mbCmapEncodingRead )
         return;
@@ -247,6 +258,7 @@
             }
         }
     }
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
@@ -432,7 +444,7 @@
     mfFakeDPIScale = 1.0;
 }
 
-void AquaSalGraphics::GetResolution( long& rDPIX, long& rDPIY )
+void AquaSalGraphics::GetResolution( sal_Int32& rDPIX, sal_Int32& rDPIY )
 {
     if( !mnRealDPIY )
         initResolution( (mbWindow && mpFrame) ? mpFrame->mpWindow : nil );
@@ -826,7 +838,7 @@
 
 // -----------------------------------------------------------------------
 
-void AquaSalGraphics::drawPolyPolygon( ULONG nPolyCount, const ULONG *pPoints, PCONSTSALPOINT  *ppPtAry )
+void AquaSalGraphics::drawPolyPolygon( sal_uInt32 nPolyCount, const sal_uInt32 *pPoints, PCONSTSALPOINT  *ppPtAry )
 {
     if( nPolyCount <= 0 )
 		return;
@@ -1038,7 +1050,7 @@
 
 // -----------------------------------------------------------------------
 
-sal_Bool AquaSalGraphics::drawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
+sal_Bool AquaSalGraphics::drawPolyPolygonBezier( sal_uInt32 nPoly, const sal_uInt32* pPoints,
                                              const SalPoint* const* pPtAry, const BYTE* const* pFlgAry )
 {
     return sal_False;
@@ -1317,7 +1329,7 @@
 
 void AquaSalGraphics::Pattern50Fill()
 {
-    static const float aFillCol[4] = { 1,1,1,1 };
+    static const CGFloat aFillCol[4] = { 1,1,1,1 };
     static const CGPatternCallbacks aCallback = { 0, &DrawPattern50, NULL };
     if( ! GetSalData()->mxP50Space )
         GetSalData()->mxP50Space = CGColorSpaceCreatePattern( GetSalData()->mxRGBSpace );
@@ -1341,7 +1353,7 @@
 
         if ( nFlags & SAL_INVERT_TRACKFRAME )
         {
-            const float dashLengths[2]  = { 4.0, 4.0 };     // for drawing dashed line
+            const CGFloat dashLengths[2]  = { 4.0, 4.0 };     // for drawing dashed line
             CGContextSetBlendMode( mrContext, kCGBlendModeDifference );
             CGContextSetRGBStrokeColor ( mrContext, 1.0, 1.0, 1.0, 1.0 );
             CGContextSetLineDash ( mrContext, 0, dashLengths, 2 );
@@ -1378,7 +1390,7 @@
         CGContextAddLines ( mrContext, CGpoints, nPoints );
         if ( nSalFlags & SAL_INVERT_TRACKFRAME )
         {
-            const float dashLengths[2]  = { 4.0, 4.0 };     // for drawing dashed line
+            const CGFloat dashLengths[2]  = { 4.0, 4.0 };     // for drawing dashed line
             CGContextSetBlendMode( mrContext, kCGBlendModeDifference );
             CGContextSetRGBStrokeColor ( mrContext, 1.0, 1.0, 1.0, 1.0 );
             CGContextSetLineDash ( mrContext, 0, dashLengths, 2 );
@@ -1522,6 +1534,9 @@
 
 void AquaSalGraphics::GetFontMetric( ImplFontMetricData* pMetric )
 {
+#if SUPD == 310
+	return;
+#else	// SUPD == 310
 	// get the ATSU font metrics (in point units)
 	// of the font that has eventually been size-limited
 
@@ -1561,6 +1576,7 @@
     // setting this width to the pixel height of the fontsize is good enough
     // it also makes the calculation of the stretch factor simple
     pMetric->mnWidth        = static_cast<long>(mfFontStretch * fPixelSize + 0.5);
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
@@ -1748,6 +1764,9 @@
 
 BOOL AquaSalGraphics::GetGlyphOutline( long nGlyphId, basegfx::B2DPolyPolygon& rPolyPoly )
 {
+#if SUPD == 310
+	return false;
+#else	// SUPD == 310
 	GgoData aGgoData;
 	aGgoData.mpPolyPoly = &rPolyPoly;
 	rPolyPoly.clear();
@@ -1767,6 +1786,7 @@
 		rPolyPoly.transform( aScale );
 	}
 	return true;
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
@@ -1792,6 +1812,9 @@
 
 BOOL AquaSalGraphics::GetGlyphBoundRect( long nGlyphId, Rectangle& rRect )
 {
+#if SUPD == 310
+	return false;
+#else	// SUPD == 310
 	ATSUStyle rATSUStyle = maATSUStyle;	// TODO: handle glyph fallback
 	GlyphID aGlyphId = nGlyphId;
 	ATSGlyphScreenMetrics aGlyphMetrics;
@@ -1806,6 +1829,7 @@
 	const long nMaxY = (long)(aGlyphMetrics.height * mfFontScale + 0.5) + nMinY;
 	rRect = Rectangle( nMinX, nMinY, nMaxX, nMaxY );
 	return true;
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
@@ -1825,6 +1849,9 @@
 
 USHORT AquaSalGraphics::SetFont( ImplFontSelectData* pReqFont, int nFallbackLevel )
 {
+#if SUPD == 310
+    return 0;
+#else	// SUPD == 310
     if( !pReqFont )
     {
     	ATSUClearStyle( maATSUStyle );
@@ -1953,6 +1980,7 @@
 #endif
 
     return 0;
+#endif	// SUPD == 310
 }
 
 // -----------------------------------------------------------------------
@@ -1997,6 +2025,9 @@
 static bool GetRawFontData( const ImplFontData* pFontData,
 	ByteVector& rBuffer )
 {
+#if SUPD == 310
+	return false;
+#else 	// SUPD == 310
 	const ImplMacFontData* pMacFont = static_cast<const ImplMacFontData*>(pFontData);
 	const ATSUFontID nFontId = static_cast<ATSUFontID>(pMacFont->GetFontId());
 	ATSFontRef rFont = FMGetATSFontRefFromFont( nFontId );
@@ -2111,10 +2142,11 @@
 	DBG_ASSERT( (nOfs==nTotalLen), "AquaSalGraphics::CreateFontSubset (nOfs!=nTotalLen)");
 
 	return true;
+#endif	// SUPD == 310
 }
 
 BOOL AquaSalGraphics::CreateFontSubset( const rtl::OUString& rToFile,
-	const ImplFontData* pFontData, long* pGlyphIDs, sal_uInt8* pEncoding,
+	const ImplFontData* pFontData, sal_Int32* pGlyphIDs, sal_uInt8* pEncoding,
 	sal_Int32* pGlyphWidths, int nGlyphCount, FontSubsetInfo& rInfo )
 {
 	ByteVector aBuffer;
--- aqua/source/gdi/salnativewidgets.cxx	2009-02-13 01:54:28.000000000 -0800
+++ aqua/source/gdi/salnativewidgets.cxx	2014-04-27 17:26:55.000000000 -0700
@@ -704,7 +704,7 @@
                 // Perhaps some other HIThemeButtonDrawInfo setting would do the trick ?
                 
                 CGContextSetShouldAntialias( mrContext, true );
-                float aGrey[] = { 0.45, 0.45, 0.45, 1.0 };
+                CGFloat aGrey[] = { 0.45, 0.45, 0.45, 1.0 };
                 CGContextSetFillColor( mrContext, aGrey );
                 CGContextBeginPath( mrContext );
                 float x = rc.origin.x + rc.size.width;
--- aqua/source/gdi/salprn.cxx	2009-07-08 05:31:40.000000000 -0700
+++ aqua/source/gdi/salprn.cxx	2014-04-27 20:56:48.000000000 -0700
@@ -442,7 +442,7 @@
 {
     if( mpPrintInfo )
     {
-        long nDPIX = 72, nDPIY = 72;
+        sal_Int32 nDPIX = 72, nDPIY = 72;
         mpGraphics->GetResolution( nDPIX, nDPIY );
         const double fXScaling = static_cast<double>(nDPIX)/72.0,
                      fYScaling = static_cast<double>(nDPIY)/72.0;
--- aqua/source/window/salframe.cxx	2009-06-30 09:25:06.000000000 -0700
+++ aqua/source/window/salframe.cxx	2014-04-27 21:02:19.000000000 -0700
@@ -1067,7 +1067,7 @@
         NSColor* pRBGColor = [pSysColor colorUsingColorSpaceName: NSDeviceRGBColorSpace device: [pWin deviceDescription]];
         if( pRBGColor )
         {
-            float r = 0, g = 0, b = 0, a = 0;
+            CGFloat r = 0, g = 0, b = 0, a = 0;
             [pRBGColor getRed: &r green: &g blue: &b alpha: &a];
             aRet = Color( int(r*255.999), int(g*255.999), int(b*255.999) );
             /*
@@ -1129,7 +1129,7 @@
         GetGraphics();
         ReleaseGraphics( mpGraphics );
     }
-	long nDPIX = 72, nDPIY = 72;
+	sal_Int32 nDPIX = 72, nDPIY = 72;
 	mpGraphics->GetResolution( nDPIX, nDPIY );
     aAppFont = getFont( [NSFont systemFontOfSize: 0], nDPIY, aAppFont );
 
--- aqua/source/window/salframeview.mm	2009-06-30 09:25:06.000000000 -0700
+++ aqua/source/window/salframeview.mm	2014-04-27 21:07:25.000000000 -0700
@@ -132,9 +132,9 @@
 
 static AquaSalFrame* getMouseContainerFrame()
 {
-    int nWindows = 0;
+    NSInteger nWindows = 0;
     NSCountWindows( &nWindows );
-    int* pWindows = (int*)alloca( nWindows * sizeof(int) );
+    NSInteger* pWindows = (NSInteger*)alloca( nWindows * sizeof(int) );
     // note: NSWindowList is supposed to be in z-order front to back
     NSWindowList( nWindows, pWindows );
     AquaSalFrame* pDispatchFrame = NULL;
